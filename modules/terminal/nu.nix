{ pkgs, ... }: {
  programs.nushell = let
    nuscripts = pkgs.fetchFromGitHub {
      owner = "nushell";
      repo = "nu_scripts";
      rev = "c65ae517d029f5d57d009dc2b36325da264d43f3";
      sha256 = "sha256-9leFXzPKSiW0m0m/XswOeUFX6eWvV2YwBQL8hLxqu4Q=";

    };
  in {
    package = pkgs.nushell;
    enable = true;

    configFile = {
      text = # nu
        ''
              $env.config = {
              table: {
                mode: rounded
              }
              show_banner: false,
              ls: {
                use_ls_colors: true
                clickable_links: true
              }
              # cd: {
              #   abbreviations: true  
              #  }
              rm: {
                always_trash: true
              }
              hooks: {
                  command_not_found: {
                      |cmd| ( 
                         let foundCommands = (nix-locate --minimal --no-group --type x --type s --top-level --whole-name --at-root ("/bin/" + $cmd) | lines | str replace ".out" "");
                         if ($foundCommands | length) == 0  {
                           print "Command not found"
                        } else if $cmd != "wl-copy" {
                            print "Command is avalible in the following packages"
                            print $foundCommands 
                            print ("nix-shell -p " + $foundCommands.0 + " coppied to clipboard") 
                            echo ("nix-shell -p " + ($foundCommands | get 0) )| wl-copy;
                        }
                      )
                  }
              }
            }


            export def rbs [] {
              sudo nixos-rebuild switch --flake ~/sys-nix#($env.hostname) -p $env.hostname;
            }

            export def x [name:string] {
              let exten = [ [ex com];
                                ['.tar.bz2' '${pkgs.gnutar}/bin/tar xjf']
                                ['.tar.gz' '${pkgs.gnutar}/bin/tar xzf']
                                ['.bz2' '${pkgs.bzip2}/bin/bunzip2']
                                ['.rar' '${pkgs.unrar}/bin/unrar x']
                                ['.tbz2' '${pkgs.gnutar}/bin/tar xjf']
                                ['.tgz' '${pkgs.gnutar}/bin/tar xzf']
                                ['.zip' '${pkgs.unzip}/bin/unzip']
                                ['.7z' '${pkgs.p7zip}/bin/7z x']
                                ['.tar.xz' '${pkgs.gnutar}/bin/tar xvf']
                                ['.tar.zst' '${pkgs.gnutar}/bin/tar xvf']
                                ['.tar' '${pkgs.gnutar}/bin/tar xvf']
                                ['.gz' '${pkgs.gzip}/bin/gunzip']
                                ['.Z' '(${pkgs.gzip}/bin/uncompress']
                                ]
              let command = ($exten|where $name =~ $it.ex|first)
              if ($command|is-empty) {
                echo 'Error! Unsupported file extension'
              } else {
                nu -c ($command.com + ' ' + $name)
              }
            }

          # export use "${nuscripts}/modules/background_task/job.nu"
          export use "${nuscripts}/modules/network/ssh.nu"
          use "${nuscripts}/custom-completions/zellij/zellij-completions.nu" *
          use "${nuscripts}/custom-completions/git/git-completions.nu" *
          use "${nuscripts}/custom-completions/cargo/cargo-completions.nu" *
          use "${nuscripts}/custom-completions/make/make-completions.nu" *
          use "${nuscripts}/custom-completions/nix/nix-completions.nu" *

          export def "cargo search" [ query: string, --limit=10] { 
              ^cargo search $query --limit $limit
              | lines 
              | each { 
                  |line| if ($line | str contains "#") { 
                      $line | parse --regex '(?P<name>.+) = "(?P<version>.+)" +# (?P<description>.+)' 
                  } else { 
                      $line | parse --regex '(?P<name>.+) = "(?P<version>.+)"' 
                  } 
              } 
              | flatten
              | each { |r| {name: $r.name, version: $r.version ,description: $r.description, link: ("https://lib.rs/" + $r.name ) } }

          }

                    # Code generated by zoxide. DO NOT EDIT.

          # =============================================================================
          #
          # Hook configuration for zoxide.
          #

          # # Initialize hook to add new entries to the database.
          # if (not ($env | default false __zoxide_hooked | get __zoxide_hooked)) {
          #   $env.__zoxide_hooked = true
          #   $env.config = ($env | default {} config).config
          #   $env.config = ($env.config | default {} hooks)
          #   $env.config = ($env.config | update hooks ($env.config.hooks | default {} env_change))
          #   $env.config = ($env.config | update hooks.env_change ($env.config.hooks.env_change | default [] PWD))
          #   $env.config = ($env.config | update hooks.env_change.PWD ($env.config.hooks.env_change.PWD | append {|_, dir|
          #     zoxide add -- $dir
          #   }))
          # }

          # # =============================================================================
          # #
          # # When using zoxide with --no-cmd, alias these internal functions as desired.
          # #

          # # Jump to a directory using only keywords.
          # def --env __zoxide_z [...rest:string] {
          #   let arg0 = ($rest | append '~').0
          #   let path = if (($rest | length) <= 1) and ($arg0 == '-' or ($arg0 | path expand | path type) == dir) {
          #     $arg0
          #   } else {
          #     (zoxide query --exclude $env.PWD -- $rest | str trim -r -c "\n")
          #   }
          #   cd $path
          # }

          # # Jump to a directory using interactive search.
          # def --env __zoxide_zi  [...rest:string] {
          #   cd $'(zoxide query --interactive -- $rest | str trim -r -c "\n")'
          # }

          # # =============================================================================
          # #
          # # Commands for zoxide. Disable these using --no-cmd.
          # #

          # alias z = __zoxide_z
          # alias zi = __zoxide_zi

          # =============================================================================
          #
          # Add this to your env file (find it by running `$nu.env-path` in Nushell):
          #
          #   zoxide init nushell | save -f ~/.zoxide.nu
          #
          # Now, add this to the end of your config file (find it by running
          # `$nu.config-path` in Nushell):
          #
          #   source ~/.zoxide.nu
          #
          # Note: zoxide only supports Nushell v0.73.0 and above.

        '';
    };

    envFile = {
      text = # nu
        ''
          $env.DIRENV_LOG_FORMAT = ""
          $env.EDITOR = "hx"
          $env.VISUAL = "hx"
          zoxide init nushell | save -f ~/.zoxide.nu
        '';
    };

    shellAliases = (import ./shell_aliases.nix { inherit pkgs; }) // {
      unix = "curl -L http://git.io/unix";
      nix-develop = "nix develop -c nu";
      nix-shell = "nix-shell --command nu";
      ns = "nix-shell --command nu -p";
      nd = "nix develop --command nu";
      xc = "wl-copy";
      clip = "wl-copy";
      lf = "cd (fish -c ' lfcd ; pwd ')";
      i = "nix-env -iA nixos.";
      q = "exit";
      ":q" = "exit";
      c = "clear";
      r = "reset";
      za = "zellij a";
    };
  };
}
